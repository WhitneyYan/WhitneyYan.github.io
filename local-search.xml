<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>arp</title>
    <link href="/2020/10/23/arp/"/>
    <url>/2020/10/23/arp/</url>
    
    <content type="html"><![CDATA[<h1 id="一次ARP欺骗攻击复现"><a href="#一次ARP欺骗攻击复现" class="headerlink" title="一次ARP欺骗攻击复现"></a>一次ARP欺骗攻击复现</h1><h2 id="0-题目背景"><a href="#0-题目背景" class="headerlink" title="#0 题目背景"></a>#0 题目背景</h2><blockquote><p>复现ARP内网欺骗攻击，其中设置被欺骗的虚拟机的IP地址为192.168.92.135.（提示：设置虚拟机静态IP)  </p></blockquote><h2 id="1-ARP协议"><a href="#1-ARP协议" class="headerlink" title="#1 ARP协议"></a>#1 ARP协议</h2><p>主机发送信息时将包含目标IP地址的ARP请求向<strong>局域网络内</strong>所有主机广播，目标机接受后将会返回自己的物理地址。<strong>基于网络中的主机相互信任的前提</strong>，主机接受到返回的信息时将会直接写入自己的ARP缓存表中而不检查真实性，以供下一次直接读取使用。因此，若攻击机伪造ARP报文并向主机发送，主机就会根据错误的ARP报文刷新自己的缓存，以此达到攻击的目的。</p><p>本文复现单向欺骗靶机，即使靶机中的arp表的网关硬件地址从正确的硬件地址变为攻击机kali的硬件地址，从而实现流量劫持。</p><h2 id="2-设置虚拟机静态IP"><a href="#2-设置虚拟机静态IP" class="headerlink" title="#2 设置虚拟机静态IP"></a>#2 设置虚拟机静态IP</h2><p>这里以VMware中的win7虚拟机为例。</p><p>首先打开命令行窗口，输入</p><pre><code class="hljs ebnf"><span class="hljs-attribute">arp -a</span></code></pre><p>查看IP地址及MAC地址，发现并不是192.168.92.135，因此我们需要设置虚拟机静态IP。</p><ol><li>打开虚拟机中的虚拟网络编辑器（编辑 -&gt;虚拟网络编辑器），<img src="%5Cimg%5Carp-1.png" srcset="/img/loading.gif" alt=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kruskal算法</title>
    <link href="/2020/08/29/kruskal/"/>
    <url>/2020/08/29/kruskal/</url>
    
    <content type="html"><![CDATA[<h1 id="Kruskal算法简介"><a href="#Kruskal算法简介" class="headerlink" title="Kruskal算法简介"></a>Kruskal算法简介</h1><p>Kruskal算法的具体思路是，为了造出一棵最小生成树，我们从z最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就跳过选择这条边，直到加入了 n-1条边，即形成了一棵树。</p><pre><code class="hljs r">证明：使用归纳法，证明任何时候Kruskal算法选择的边集都被某棵最小生成树所包含。基础：对于算法刚开始时，显然成立（最小生成树存在）。归纳：假设某时刻成立，当前边集为<span class="hljs-literal">F</span>，令<span class="hljs-literal">T</span>为这棵最小生成树，考虑下一条加入的边 e。如果 e属于<span class="hljs-literal">T</span>  ，那么成立。否则，<span class="hljs-literal">T</span>+e一定存在一个环，考虑这个环上不属于<span class="hljs-literal">F</span>的另一条边f （一定只有一条）。首先，f的权值一定不会比 e小，不然f会在e之前被选取。然后，f的权值一定不会比 e大，不然<span class="hljs-literal">T</span>+e-f就是一棵比<span class="hljs-literal">T</span>还优的生成树了。所以，<span class="hljs-literal">T</span>+e-f包含了<span class="hljs-literal">F</span>，并且也是一棵最小生成树，归纳成立。</code></pre><p>对于是否形成环，可以利用并查集进行判定。具体代码如下：</p><pre><code class="hljs gml">int find(int <span class="hljs-symbol">x</span>)&#123;            <span class="hljs-keyword">return</span> (p[<span class="hljs-symbol">x</span>]==<span class="hljs-symbol">x</span>)? <span class="hljs-symbol">x</span>: (p[<span class="hljs-symbol">x</span>]=find(p[<span class="hljs-symbol">x</span>]));&#125;</code></pre><p>未开始选择边时，每一条边都独立于其它边存在，即：</p><pre><code class="hljs matlab"><span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>; <span class="hljs-built_in">i</span>&lt;n; <span class="hljs-built_in">i</span>++)   p[<span class="hljs-built_in">i</span>]=<span class="hljs-built_in">i</span>;</code></pre><p>根据边权对边进行排序：</p><pre><code class="hljs armasm"><span class="hljs-keyword">bool </span><span class="hljs-keyword">cmp(const </span>edge &amp;<span class="hljs-built_in">p1</span>, const edge &amp;<span class="hljs-built_in">p2</span>)&#123;return <span class="hljs-built_in">p1</span>.w&lt;<span class="hljs-built_in">p2</span>.w<span class="hljs-comment">;</span>&#125;<span class="hljs-symbol">sort</span>(myedge, myedge+m, <span class="hljs-keyword">cmp);</span></code></pre><p>开始选择及判定：</p><pre><code class="hljs gml"><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;w=myedge[i].w;<span class="hljs-symbol">x</span>=find(myedge[i].u);    <span class="hljs-symbol">y</span>=find(myedge[i].v);<span class="hljs-keyword">if</span>(<span class="hljs-symbol">x</span>!=<span class="hljs-symbol">y</span>)&#123;                <span class="hljs-comment">//不构成环时</span>ans+=w;    counter++;    p[<span class="hljs-symbol">y</span>]=<span class="hljs-symbol">x</span>;    <span class="hljs-keyword">if</span>(counter==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//形成树时完成选边</span>     &#125; &#125;</code></pre><h1 id="最小生成树基础拓展"><a href="#最小生成树基础拓展" class="headerlink" title="最小生成树基础拓展"></a>最小生成树基础拓展</h1><p>Kruskal算法的核心思想是按照边权的升序选择不形成环的边加入树中，在实际问题中，我们所需要的可能不仅仅是最小生成树，而对选择的边有其他的要求，但Kruskal算法中对边按边权进行选择的思想仍然可以帮助我们解决问题。</p><p>以洛谷P2121 拆地毯为例:</p><blockquote><p>会场上有 n 个关键区域，不同的关键区域由 m 条无向地毯彼此连接。每条地毯可由三个整数 u、v、w 表示，其中 u 和 v 为地毯连接的两个关键区域编号，w 为这条地毯的美丽度。<br>由于颁奖典礼已经结束，铺过的地毯不得不拆除。为了贯彻勤俭节约的原则，组织者被要求只能保留 K 条地毯，且保留的地毯构成的图中，任意可互相到达的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在组织者求助你，想请你帮忙&gt;算出这 K 条地毯的美丽度之和最大为多少。</p></blockquote><p>此题对最小生成树的算法存在两处拓展：<br>1、  需要的是边权和（美丽度之和）最大，因此需将边按边权降序排列；<br>2、 生成的不一定是最小生成树而是具有k条边的树，即任意两点之间不一定相通，但相通的两点之间一定不形成环。    </p><p>由以上分析对Kruskal算法进行拓展，需要修改的是：</p><pre><code class="hljs cpp"><span class="hljs-comment">//边权按降序排列</span>     <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge &amp;p1, <span class="hljs-keyword">const</span> edge &amp;p2)</span></span>&#123;            <span class="hljs-keyword">return</span> p1.w&gt;p2.w;&#125;<span class="hljs-comment">//加入k条边后即停止选择</span><span class="hljs-keyword">if</span>(counter==k) <span class="hljs-keyword">break</span>;</code></pre><p>修改以上两处后即可完成此题。具体实现代码：</p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100005</span><span class="hljs-keyword">int</span> n, m, k, ans, counter, p[N], x, y, w;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span>    <span class="hljs-keyword">int</span> u, v, w;&#125;myedge[N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge &amp;p1, <span class="hljs-keyword">const</span> edge &amp;p2)</span></span>&#123;    <span class="hljs-keyword">return</span> p1.w&gt;p2.w;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">return</span> (p[x]==x)? x: (p[x]=<span class="hljs-built_in">find</span>(p[x]));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;myedge[i].u, &amp;myedge[i].v, &amp;myedge[i].w);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)        p[i]=i;    sort(myedge, myedge+m, cmp);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;        w=myedge[i].w;        x=<span class="hljs-built_in">find</span>(myedge[i].u);        y=<span class="hljs-built_in">find</span>(myedge[i].v);        <span class="hljs-keyword">if</span>(x!=y)&#123;            ans+=w;            counter++;            p[y]=x;            <span class="hljs-keyword">if</span>(counter==k) <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>此外，还有洛谷P1991 无线通讯网：</p><blockquote><p>国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；<br>每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。<br>任意两个配备了一条卫星电话线路的哨所（两边都有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。<br>收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。</p></blockquote><p>此题为最小生成树的变形，建造卫星电话即可构造0权边，显然应选取边权较大的两点构造0权边，故可采用Kruskal算法并少选取x条边；<br><strong>对于s个点，x=s-1</strong>，证明如下：</p><blockquote><p>1、若这s个点构成一棵树，显然成立；<br>2、若这s个点不构成树，设形成了n个联通分支，则已可以删去（s-n-1）条边；<br>在任意两个联通分支中选择两根结点，这两点及其之间的路径可构成一个环（把这两个点视为同一个点），则在该环中，一定可以删去一条边，该边满足连接两端点的路径中通过两个根结点的点的路径大于原路径，那么又要删去n条边，则总共仍要删去(s-1)条边；<br>那么需要构造的是有(p-1)-(s-1)=p-s条边的生成树，剩下的点用卫星电话连接即可。</p></blockquote><p>在代码实现时，只需将停止加边的条件改为</p><pre><code class="hljs lisp">if(<span class="hljs-name">counter==</span>(<span class="hljs-name">p-s</span>)) break<span class="hljs-comment">;</span></code></pre><p>即可。具体实现代码：</p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 1005</span><span class="hljs-keyword">int</span> n, m, p[N], cnt=<span class="hljs-number">0</span>, x, y, counter;<span class="hljs-keyword">double</span> sum, value;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span>    <span class="hljs-keyword">int</span> x, y;&#125;node[N];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span>    <span class="hljs-keyword">int</span> u, v;    <span class="hljs-keyword">double</span> value;&#125;myedge[N*N];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge &amp;p1, <span class="hljs-keyword">const</span> edge &amp;p2)</span></span>&#123;    <span class="hljs-keyword">if</span>(p1.value==p2.value) <span class="hljs-keyword">return</span> p1.u&lt;p2.u;    <span class="hljs-keyword">return</span> p1.value&lt;p2.value;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">return</span> (p[x]==x)? x : (p[x]=<span class="hljs-built_in">find</span>(p[x]));&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)<span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)(node[v].x-node[u].x)*(node[v].x-node[u].x)+(<span class="hljs-keyword">double</span>)(node[v].y-node[u].y)*(node[v].y-node[u].y));&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;node[i].x, &amp;node[i].y);       p[i]=i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;            myedge[cnt].u=i;            myedge[cnt].v=j;            myedge[cnt++].value=len(i, j);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;myedge[cnt].u, &amp;myedge[cnt].v);        myedge[cnt++].value=<span class="hljs-number">0.0</span>;    &#125;    sort(myedge, myedge+cnt, cmp);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;cnt; i++)&#123;        value=myedge[i].value;        x=<span class="hljs-built_in">find</span>(myedge[i].u);        y=<span class="hljs-built_in">find</span>(myedge[i].v);        <span class="hljs-keyword">if</span>(x!=y)&#123;            sum+=value;            p[y]=x;            counter++;            <span class="hljs-keyword">if</span>(counter&gt;=n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown进阶语法</title>
    <link href="/2020/07/04/markdown-advanced/"/>
    <url>/2020/07/04/markdown-advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h1><ul><li>打开高亮：文件<code>File</code> -&gt; 偏好设置<code>Preference</code> -&gt; Markdown<code>Markdown</code> -&gt; 高亮<code>highlight</code></li><li>使用<code>==</code>包裹文本即可。<br>== 大概是无法显示的高亮内容 ==<h1 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h1></li><li>使用语法（以:smile:为例）<code>smile</code>。</li><li>可以通过按<code>ESA</code>键触发emoji的自动补全建议，也可以通过设置<code>偏好设置</code>来自动触发建议。同时，也可以在菜单栏中的<code>编辑</code>-&gt;<code>Emoji &amp; Symbols</code>直接插入UTF-8字符（仅限于macOS）。</li><li>可通过更改渲染器实现emoji功能<del>但我懒得换了</del><h1 id="上标及下标"><a href="#上标及下标" class="headerlink" title="上标及下标"></a>上标及下标</h1></li><li>在偏好设置中打开</li><li>上标使用<code>^</code>包裹，下标使用<code>~</code>包裹，例：<pre><code class="hljs angelscript">H~<span class="hljs-number">2</span>~Ox^<span class="hljs-number">2</span></code></pre></li><li>可使用HTML语法创建上下标，具体见<a href="https://whitneyyan.github.io/2020/07/01/markdown_basic/#%E4%B8%8A%E6%A0%87%E5%8F%8A%E4%B8%8B%E6%A0%87" target="_blank" rel="noopener">markdown上标及下标</a>。<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1></li><li>创建脚注：<code>[^脚注]</code>，<code>[^脚注]：脚注文本。</code><pre><code class="hljs css">此处有脚注<span class="hljs-selector-attr">[^脚注]</span>。<span class="hljs-selector-attr">[^脚注]</span>：脚注文本。</code></pre></li><li>鼠标悬停即可查看。</li><li>脚注文本可置于文末。</li><li>脚注中使用英文冒号。<h1 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h1>使用如下规则创建：<pre><code class="hljs tex"><span class="hljs-formula">$<span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123;green&#125;</span><span class="hljs-string">&#123;绿色&#125;</span></span> $</span></code></pre>显示效果：$\color{green}{绿色} $</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown基础语法总结</title>
    <link href="/2020/07/01/markdown_basic/"/>
    <url>/2020/07/01/markdown_basic/</url>
    
    <content type="html"><![CDATA[<p><strong>总结自markdown官方文档</strong><br><em>不包含数学公式、YAML、HTML等内容，<del>太复杂了</del>在学了在学了</em></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>markdown主要用两种形式表示标题：  </p><ul><li><p>使用 = 和 - 标记一级和二级标题：</p><pre><code class="hljs asciidoc">一级标题 ======二级标题-------</code></pre></li><li><p>使用1~6个#标记，#与标题间应有空格</p><pre><code class="hljs clean"># 一级标题## 二级标题### 三级标题</code></pre><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2></li><li><p>在末尾通过两个以上空格加上回车</p><pre><code class="hljs plain">段落  ↓</code></pre></li><li><p>在段落后空出一行表示重新开始一个段落</p><pre><code class="hljs angelscript">段落<span class="hljs-number">1</span>段落<span class="hljs-number">2</span></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>1. 基本使用</strong></p><ul><li><p>无序列表使用 * 、+ 、- 标记，标记后需一个空格。</p><pre><code class="hljs markdown"><span class="hljs-bullet">* </span>第一项<span class="hljs-bullet">+ </span>第二项<span class="hljs-bullet">- </span>第三项</code></pre></li><li><p>有序列表使用数字并加上 . 号来表示。  </p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 第一项<span class="hljs-number">2.</span> 第二项</code></pre><p><strong>2. 列表嵌套</strong><br>在子列表前添加制表符tab（四个空格）。</p>  <pre><code class="hljs markdown"><span class="hljs-bullet">1. </span>第一项：<span class="hljs-bullet">     - </span>第一项嵌套元素</code></pre><p><strong>3.  任务表</strong><br>使用[ ]或 [x] 表示（x为字母x）：</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[ ] 未完成<span class="hljs-bullet">- </span>[x] 已完成</code></pre><p>显示效果：</p></li></ul></li></ul><ul><li><input disabled="" type="checkbox"> 未完成</li><li><input checked="" disabled="" type="checkbox"> 已完成<h2 id="引文区块"><a href="#引文区块" class="headerlink" title="引文区块"></a>引文区块</h2></li></ul><ul><li><p><strong>在段落开头使用 &gt; 标记区块：</strong></p><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 区块</span></code></pre></li><li><p><strong>区块嵌套</strong><br>利用 &gt; 的数量进行嵌套</p><pre><code class="hljs ruby">&gt; 最外层<span class="hljs-meta">&gt;&gt;</span> 第一层嵌套</code></pre></li><li><p><strong>列表中使用区块</strong><br>在 &gt; 前添加四个空格缩进</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>第一项<span class="hljs-code">&gt; 嵌套区块</span></code></pre><p>显示效果：</p></li><li><p>第一项</p><blockquote><p>嵌套区块</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2></li></ul><ul><li>代码片段使用反括号(`)包起来</li><li>代码区块使用制表符或（```)<pre><code class="hljs isbl">(<span class="hljs-variable"><span class="hljs-built_in">tab</span></span>)<span class="hljs-function"><span class="hljs-title">printf</span>()</span></code></pre></li><li>用```时可指定语言<blockquote><p>``` markdown<br>*斜体*<br>```</p></blockquote></li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>使用<code>|</code>分割单元格，<code>-</code>分割表头和其他行<pre><code class="hljs gherkin">|<span class="hljs-string"> 表头 </span>|<span class="hljs-string"> 表头 </span>||<span class="hljs-string"> --- </span>|<span class="hljs-string"> --- </span>||<span class="hljs-string">单元格</span>|<span class="hljs-string">单元格</span>|</code></pre>显示效果<table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr></tbody></table></li><li>对齐方式<ul><li><code>-:</code>居右对齐</li><li><code>:-</code>居左对齐</li><li><code>:-:</code>居中对齐<br>实例：<pre><code class="hljs gherkin">|<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 右对齐 </span>|<span class="hljs-string"> 居中对齐 </span>||<span class="hljs-string"> :-----</span>|<span class="hljs-string"> ----: </span>|<span class="hljs-string"> :----: </span>||<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|<span class="hljs-string"> 单元格 </span>|</code></pre>显示效果：<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul></li></ul><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><ul><li>在空白行输入<code>***</code>或<code>---</code>可生成分割线。</li><li>符号大于3个即可。<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2></li><li>输入<code>[toc]</code>并按下回车可创建目录。</li><li>在输入处创建。<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a><em>斜体</em></h2>使用一个 <code>*</code> 或<code>_</code><pre><code class="hljs haxe">*斜体文本*<span class="hljs-literal">_</span>斜体文本<span class="hljs-literal">_</span></code></pre><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a><strong>粗体</strong></h2>使用 <code>**</code> 或<code>__</code>   <pre><code class="hljs markdown"><span class="hljs-strong">**粗体文本**</span><span class="hljs-strong">__粗体文本__</span></code></pre><h2 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a><strong><em>粗斜体</em></strong></h2>使用<code>***</code>或<code>___</code><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h2></li><li>使用<code>~~</code>包裹文本。</li><li>GFM增加了带有删除线文本的语法，这个功能在标准的Markdown中是没有的。<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a><u>下划线</u></h2></li><li>由HTML实现。</li><li>用<code>&lt;u&gt;文本&lt;/u&gt;</code>包裹文本即可。<h2 id="上标及下标"><a href="#上标及下标" class="headerlink" title="上标及下标"></a>上标及下标</h2></li><li>可使用HTML语法创建。</li><li>上标：使用<code>&lt;sup&gt;&lt;/sup&gt;</code>包裹文本，例<code>O&lt;sup&gt;2&lt;/sup&gt;</code>， 即O<sup>2</sup>。</li><li>下标：使用<code>&lt;sub&gt;&lt;/sub&gt;</code>包裹文本，例<code>H&lt;sub&gt;2&lt;/sub&gt;</code>，即H<sub>2</sub>。<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2></li><li>行内链接：<pre><code class="hljs markdown">[<span class="hljs-string">链接名称</span>](<span class="hljs-link">链接地址"Title"</span>)或<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">链接地址</span>&gt;</span></span></code></pre></li><li>Title属性可省略</li><li>引用链接：<pre><code class="hljs markdown">[<span class="hljs-string">链接名称</span>][<span class="hljs-symbol">id</span>]在文档任意处定义链接：[<span class="hljs-symbol">id</span>]:<span class="hljs-link">链接地址 "Title"</span></code></pre></li><li>适用于被定义的链接需多次使用。<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2>图片的语法格式和链接非常相似，只是它们需要在链接起始的地方加一个<code>!</code>字符。<pre><code class="hljs markdown">![<span class="hljs-string">图片备注</span>](<span class="hljs-link">链接地址</span>)</code></pre></li><li>typora支持通过拖拽的方式把文件或者网页中的图片插入进来。点击图片之后，就能修改它的markdown源代码。如果拖拽的图片在正在编辑的文件的同一级或次一级目录中，将会使用相对路径。</li><li>如果你正在使用markdown搭建网站，你需要在最开头的YAML Front Matters中加入<code>typora-root-url</code>属性，声明一个在你的本地电脑中预览图片的URL前缀。比如，在YAML Front Matters中输入<code>typora-root-url:/User/Abner/Website/typora.io/</code>，那么<code>![alt](/blog/img/test.png)</code>在Typora中就会被识别为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code>。<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2>markdown支持以下符号前加上 \  以显示普通字符：<table><thead><tr><th>字符</th><th></th></tr></thead><tbody><tr><td>\</td><td>反斜线</td></tr><tr><td>`</td><td>反引号</td></tr><tr><td>*</td><td>星号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>{}</td><td>花括号</td></tr><tr><td>[]</td><td>方括号</td></tr><tr><td>()</td><td>小括号</td></tr><tr><td>#</td><td>井字号</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr><tr><td>.</td><td>英文句点</td></tr><tr><td>!</td><td>感叹号</td></tr></tbody></table></li></ul><h2 id="血泪教训"><a href="#血泪教训" class="headerlink" title="血泪教训"></a>血泪教训</h2><ul><li>建议尽量使用<code>+</code>建立列表以与粗体、斜体避免歧义 。</li><li>表格一定要加表头。</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World！</title>
    <link href="/2020/06/26/hello-world/"/>
    <url>/2020/06/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
